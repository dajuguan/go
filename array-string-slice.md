# 数组、字符串和切片
Go语言中数组、字符串和切片是三种密切相关且使用的最为频繁的数据结构，只有不能满足需求时才会考虑更加复杂的自定义数据结构。
- 数组是一种值类型，虽然数组的元素可以修改，但数组本身的赋值和函数传参是通过**整体赋值的方式**也就是**传值**，而不是引用传递。
- 字符串对应的也是字节数组，只是它是只读的，不能像数组可以修改；字符串的赋值只复制数据地址和长度，不会导致底层数据的复制，也是**传值方式**
- 切片的结构类似于字符串，但是更为灵活。它的底层数据也是对应数据类型的数组，但是每个切片有独立的长度和容量信息，并且切片的赋值和传参都是采用**传值方式**。

## 数组
### 定义
数组的元数据包括：
- 长度
- 0个或多个元素
- 类型 (可以使字符串、结构体、函数、接口、管道等)
  
不同长度或者类型的数组无法直接赋值。

可以由四种定义方式：
直接定义：
```
var a[3]init
var aa[3]string
//0,0,0
```
初始化赋值，按顺序指定初始化的值，长度自动计算
```
var b = [...]int{1,2,3}
var bb = [2]string("hello", "你好") //支持中文
//1,2,3
```
索引方式，索引与值对应，长度以最大索引为准，其他的为0
```
var c = [...]int{2:3, 1:2}
//0,2,3
```
混合方式,前两个元素按顺序初始化，第三四个初始化为0，第五个元素索引初始化为5，最后一个元素接着按顺序初始化：
```
var d = [...]int{1,2,4:5,6}
//1,2,0,0,5,6
```
从下图可以看出，数组数据在内存中连续存储：
![数组存储](/.gitbook/assets/数组的存储.png)

数组的名字代表的就是整个数组，而不是像c代表第一个袁术的指针。因此当数组被赋值或者被值传递的时候，实际上会复制整个数据。如果数组较大会产生比较大的开销，为了避免复制数组带来的开销，可以采用指针传递

```
package main
import "fmt"
func main() {
   var a = [...]int{1,2}
   var b = a
   var c = &a
   fmt.Println(a,b,c)  
   c[0] = 3
   fmt.Println(a,b,c)  //b的值没有发生变化，可见赋值是整体复制
}
```

### 遍历
可以使用fmt.Printf函数来打印数组的类型和详细信息，同时可用下述三种for循环来遍历：
```
package main
import "fmt"
func main() {
   var a = [...]int{1,2}
   for i,v := range(a){
      fmt.Println(i,a[i],v)
   } //i代表索引，v代表值
   for _, v := range(a){
      fmt.Println(v)
   } //_不使用索引，v代表值
   for i := 0; i < len(a); i++ {
      fmt.Println(a[i])
   }
   fmt.Printf("a: %T\n", a)
   fmt.Printf("a: %v\n", a)
}
```
